{% extends 'base.html.twig' %}

{% block title %}

	{{ parent() }}-Chap3.4
	
{% endblock %}

{% block body %}

	{{ parent() }}

{% endblock %}

{% block body_content %}	
	<h3>
		<a href="https://openclassrooms.com/courses/developpez-votre-site-web-avec-le-framework-symfony/recuperer-ses-entites-avec-doctrine2-1">
			Chap 3.3 -   Récupérer ses entités avec Doctrine2 
		</a>
	</h3>
	
	<p>Un repository centralise tout ce qui touche à la récupération de vos entités... sans requête SQL.</p>
	<p>Deux façons pour construire vos requêtes de récupération des entités:<p>
	<ul>
		<li>
			<a href="#dql">Le DQL</a>
			<pre>SELECT a FROM OCPlatformBundle:Advert a</pre>
		</li>
		<li>
			Le QueryBuilder
			<pre>$queryBuilder
  ->select('a')
  ->from('OCPlatformBundle:Advert', 'a')
;
$queryBuilder->andWhere('champ = 1'); // fonctionne dans les deux cas: where existe déjà ou pas.</pre>
	</ul>
	
	<h4>Les méthodes normales</h4>
	<pre>$repository = $this->getDoctrine()->getManager()->getRepository('OCPlatformBundle:Advert');
$advert = $repository->find(5);
$adverts = $repository->findAll();	// Retourne un array
$listAdverts = $repository->findBy(
  array('author' => 'Alexandre'), // Critere
  array('date' => 'desc'),        // Tri
  5,                              // Limite
  0                               // Offset
);
$advert = $repository->findOneBy(array('author' => 'Marine')); // idem findBy, retourne une seule entité.
</pre>

	<h4>
		<a href="http://php.net/manual/fr/language.oop5.magic.php">
			Les méthodes magiques
		</a>
	</h4>
	<p>Deux méthodes gérées par __call() dans les repositories: findByX($valeur) et findOneByX($valeur)</p>
	<pre>$listAdverts = $repository->findByAuthor('Alexandre'); // ou findByTitle(), findByDate(), findByContent()</pre>
	<pre>$advert = $repository->findOneByTitle('Recherche développeur.');</pre>
	
	<h4>Les méthodes de récupération personnelle</h4>
	<p>Trois types d'objet distincts: le QueryBuilder, la Query et les résultats.</p>
	<h5>Le QueryBuilder</h5>
	<p>Récupérer un QueryBuilder (vide):</p>
	<pre>$this->_em->createQueryBuilder()</pre>
	<pre>namespace OC\PlatformBundle\Repository;

/**
 * AdvertRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class AdvertRepository extends \Doctrine\ORM\EntityRepository {
	public function myFindAll() {
		//Méthode 1 en passant par l'EntityManager 'a' est le raccourci que l'on donne à l'entité du repository.
		$queryBuilder = $this->_em->CreateQueryBuilder()
			->select('a')
			->from($this->_entityName, 'a')
		;
		// Dans un repository, $this->_entityName est le namespace de l'entité gérée
		// Ici, il vaut donc OC\PlatformBundle\Entity\Advert
		
		// Méthode 2 : en passant par le raccourci (recommandée)
		$queryBuilder = $this->createQueryBuilder('a');
		
		$query = $queryBuilder->getQuery(); // On récupère la Query à partir du QueryBuilder
		//return $query->getResult(); // On retourne les résutats à partir de la Query
		// méthode raccourcie:
		return $this->createQueryBuilder('a')->getQuery()->getResult();
	}
}
	</pre>
	<p>Les méthodes</p>
	<pre>public function myFindOne($id) {
  $qb = $this->createQueryBuilder('a');
  $qb->where('a.id = :id')->setParameter('id', $id);
  return $qb->getQuery()->getResult();
}</pre>
	<pre>public function findByAuthorAndDate($author, $year) {
  $qb = $this->createQueryBuilder('a');

  $qb->where('a.author = :author')
       ->setParameter('author', $author)
     ->andWhere('a.date < :year')
       ->setParameter('year', $year)
     ->orderBy('a.date', 'DESC')
  ;

  return $qb->getQuery()->getResult();
}</pre>

	<h4>Ajouter des conditions, jointures, etc...</h4>
	<pre>// src/OC/PlatformBundle/Entity/AdvertRepository.php

namespace OC\PlatformBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\QueryBuilder; // N'oubliez pas ce use

class AdvertRepository extends EntityRepository {
  public function whereCurrentYear(QueryBuilder $qb) {
    $qb
      ->andWhere('a.date BETWEEN :start AND :end')
      ->setParameter('start', new \Datetime(date('Y').'-01-01'))  // Date entre le 1er janvier de cette année
      ->setParameter('end',   new \Datetime(date('Y').'-12-31'))  // Et le 31 décembre de cette année
    ;
  }
}</pre>
	<pre>// Depuis un repository
public function myFind()
{
  $qb = $this->createQueryBuilder('a');

  // On peut ajouter ce qu'on veut avant
  $qb->where('a.author = :author')->setParameter('author', 'Marine');

  // On applique notre condition sur le QueryBuilder
  $this->whereCurrentYear($qb);

  // On peut ajouter ce qu'on veut après
  $qb->orderBy('a.date', 'DESC');

  return $qb->getQuery()->getResult();
}</pre>
	<p>
		<a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/query-builder.html">
			Doc sur les QueryBuilder
		</a>
	</p>
	
	<h4>Les différentes façons d'extraire les résultats de la requête.</h4>
	<pre>$listAdverts = $qb->getQuery()->getResult(); // Retourne un tableau (d'objet(s)).
$listAdverts = $qb->getQuery()->getArrayResult(); // Retourne un tableau de tableaux
$values = $qb->getQuery()->getScalarResult(); // Retourne un tableau de valeurs (select count(*) par ex)
$advert = $qb->getQuery()->getOneOrNullResult(); // Retourne un seul résultat ou null
  // déclenche une exception Doctrine\ORM\NonUniqueResultException si la requête retourne plus d'un seul résultat.
$advert = $qb->getQuery()->getSingleResult(); // Retourne un seul résultat
  // déclenche une exception Doctrine\ORM\NoResultException si aucun résultat.
  // Très utilisée
$value = $qb->getQuery()->getSingleScalarResult(); // Retourne une seule valeur
  // déclenche des exceptions si pas de résultat ou plus d'un résultat.
  // très utilisée également pour des requêtes du type SELECT COUNT(*)...
$qb->getQuery()->execute(); // Exécute une requête du type update, insert into...
// Voici deux méthodes strictement équivalentes :
$results = $query->getArrayResult();
// Et :
$results = $query->execute(array(), Query::HYDRATE_ARRAY);
// Le premier argument de execute() est un tableau de paramètres
// Vous pouvez aussi passer par la méthode setParameter(), au choix
// Le deuxième argument de execute() est ladite méthode d'hydratation
</pre>
	
	<h4 id="dql">Le DQL - Doctrine Query Langage</h4>
	<p>
		<a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/dql-doctrine-query-language.html">
			Doc
		</a>
	</p>
	<pre>// Depuis un repository
public function myFindAllDQL() {
  $query = $this->_em->createQuery('SELECT a FROM OCPlatformBundle:Advert a');
  $results = $query->getResult();
  return $results;
}</pre>
	<p>Tester avec la console:</p>
	<pre>php bin/console doctrine:query:dql "SELECT a FROM OCPlatformBundle:Advert a"</pre>
	<p>Exemples:</p>
	<pre>SELECT a, u FROM Advert a JOIN a.user u WHERE u.age = 25
SELECT a FROM Advert a WHERE TRIM(a.author) = 'Alexandre'
  //attention toutes les fonctions SQL ne sont pas implémentées en DQL
SELECT a.title FROM Advert a WHERE a.id IN(1, 3, 5)
  //attention les résultats seront donc sous forme de tableaux et non d'objets</pre>
	<pre>public function myFindDQL($id) {
  $query = $this->_em->createQuery('SELECT a FROM Advert a WHERE a.id = :id');
  $query->setParameter('id', $id);
  // Utilisation de getSingleResult car la requête ne doit retourner qu'un seul résultat
  return $query->getSingleResult();
}</pre>

	<h4>Utiliser les jointures dans nos requêtes</h4>
	<h5>Comment faire des jointures avec le QueryBuilder ?</h5>
	<pre>// Depuis le repository d'Advert
public function getAdvertWithApplications() {
  $qb = $this
    ->createQueryBuilder('a')
    ->leftJoin('a.applications', 'app')
    ->addSelect('app')
  ;
  return $qb->getQuery()->getResult();
}</pre>
	<p>leftJoin ou innerJoin</p>
	<p>Arguments: attribut de l'entité principale (a.applications), alias de l'entité jointe.</p>
	<p>addSelect('app') et non select('app') car cela ecraserait le premier select.</p>
	<p>Pas de ON, Doctrine connait tout sur l'association. ON n'existe pas en DQL:</p>
	<pre>$qb->innerJoin('a.applications', 'app', 'WITH', 'YEAR(app.date) > 2013')</pre>
	<p>Utilisation:</p>
	<pre>// Depuis un contrôleur
public function listAction() {
  $listAdverts = $this
    ->getDoctrine()
    ->getManager()
    ->getRepository('OCPlatformBundle:Advert')
    ->getAdvertWithApplications()
  ;

  foreach ($listAdverts as $advert) {
    // Ne déclenche pas de requête : les candidatures sont déjà chargées !
    $advert->getApplications();
  }
  // …
}</pre>
	
	<h4>Application</h4>
	<pre>// src/OC/PlatformBundle/Entity/AdvertRepository.php
//..
public function getAdvertWithCategories(array $categoryNames) {
    $qb = $this->createQueryBuilder('a')
      ->innerJoin('a.categories', 'c')
      ->addSelect('c')
      ->where($qb->expr()->in('c.name', $categoryNames));
    return $qb->getQuery()->getResult();
  }
}</pre>
	<pre>// src/OC/PlatformBundle/Entity/AdvertRepository.php
public function getApplicationsWithAdvert($limit) {
    $qb = $this->createQueryBuilder('a');
      ->innerJoin('a.advert', 'adv')
      ->addSelect('adv')
      ->setMaxResults($limit);
    return $qb->getQuery()->getResult();
  }</pre>
	
  	
	<h4>En résumé</h4>
	<ul>
		<li>Le rôle d'un repository est, à l'aide du langage DQL ou du constructeur de requêtes, de récupérer des entités selon des contraintes, des tris, etc.</li>
		<li>Un repository dispose toujours de quelques méthodes de base, permettant de récupérer de façon très simple les entités.</li>
		<li>Mais la plupart du temps, il faut créer des méthodes personnelles pour récupérer les entités exactement comme on le veut.</li>
		<li>Il est indispensable de faire les bonnes jointures afin de limiter au maximum le nombre de requêtes SQL sur vos pages.</li>
	</ul>
		
{% endblock %}
